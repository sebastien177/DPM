package ev3Navigation;
/* Lab 3 Navigation
 * Group 7
 * Sebastien Arrese & Arnold Kokoroko
 */
import lejos.hardware.motor.EV3LargeRegulatedMotor;

public class Navigation extends Thread {
	double currentX, currentY, targetX, targetY; // Current Position / Target Position
	double currentTheta;
	Odometer odometer; 

	// Class constants
	private static final long navigationPeriod = 25;
	private static final double wheelRadius = 2.145;
	private static final double wheelDistance = 15.25;
	private static final double errorThreshold = 5; 

	private static final int rotationSpeed = 180; 
	private static final int fwdSpeed = 360; 
	private static final int turnSpeed = 240; 


	// Coordinates for Navigation
	Coordinate c0 = new Coordinate(0, 0); // Start 0,0
	Coordinate c1 = new Coordinate(60, 30);
	Coordinate c2 = new Coordinate(30, 30);
	Coordinate c3 = new Coordinate(30, 60);
	Coordinate c4 = new Coordinate(60, 0); // End 0,0
	
	public Navigation(Odometer odometer) {
		this.odometer = odometer;
	}
	
	public void run (){
		long updateStart, updateEnd;
		
		while (true) {
			updateStart = System.currentTimeMillis();
			currentX = odometer.getX();
			currentY = odometer.getY();
			currentTheta = odometer.getTheta()*(180/Math.PI); //Converting Radians to Pi
			
			if (currentTheta > 180) {
				odometer.setTheta(currentTheta - 360);
			} else if (currentTheta < -180) {
				odometer.setTheta(currentTheta + 360);
			}
			
			
			
			
		}
	}
	
	
	// Travel to absolute field location
	public void travelTo(double x, double y) {

		// Coordinate difference
		double deltaX = x - this.currentX;
		double deltaY = y - this.currentY;
		double targetTheta = Math.toDegrees(Math.atan2(deltaY, deltaX));
		double deltaTheta = targetTheta - Math.toDegrees(odometer.getTheta());
		
		// if the heading is off by more than acceptable error, we must correct
		if (Math.abs(deltaTheta) > ERROR_THRESHOLD) {
			turnTo(targetTheta);
		} else {
			leftMotor.setSpeed(FORWARD_SPEED);
			rightMotor.setSpeed(FORWARD_SPEED);
			leftMotor.forward();
			rightMotor.forward();
		}
	}

	public void turnTo(double targetTheta) {
		double currentTheta = odometer.getTheta();
		double rotate = targetTheta - currentTheta;

		// If at a point, turn to in place
		if (coord0.isAtPoint(x, y) || coord1.isAtPoint(x, y)
				|| coord2.isAtPoint(x, y) || coord3.isAtPoint(x, y)
				|| coord4.isAtPoint(x, y)) {

			// turn a minimal angle
			if (rotate > 180) {
				rotate -= 360;
			} else if (rotate < -180) {
				rotate += 360;
			}

			leftMotor.setSpeed(ROTATE_SPEED);
			rightMotor.setSpeed(ROTATE_SPEED);

			leftMotor.rotate(-convertAngle(LEFT_RADIUS, WHEEL_BASE, rotate),
					true);
			rightMotor.rotate(convertAngle(RIGHT_RADIUS, WHEEL_BASE, rotate),
					false);
		}
		// turn while travelling by adjusting motor speeds
		else if (rotate > 0) {
			leftMotor.setSpeed(TURNING_SPEED); // correct left
			rightMotor.setSpeed(FORWARD_SPEED);

		} else if (rotate < 0) {
			leftMotor.setSpeed(FORWARD_SPEED);
			rightMotor.setSpeed(TURNING_SPEED); // correct right
		}
	}

	// return true if another thread has called travelTo() or turnTo()
	// and has yet to return
	public boolean isNavigating() {
		return false;
	}

	// gets the x and y targets from the specified coordinates
	public void setTarget(Coordinate coord) {
		xTarget = coord.getX();
		yTarget = coord.getY();
	}

	// returns the number of degrees the wheels must turn over a distance
	private static int convertDistance(double radius, double distance) {
		return (int) ((180.0 * distance) / (Math.PI * radius));
	}

	// returns the number of degrees to turn a certain angle
	private static int convertAngle(double radius, double width, double angle) {
		return convertDistance(radius, Math.PI * width * angle / 360.0);
	}
	
	
	
	

}
