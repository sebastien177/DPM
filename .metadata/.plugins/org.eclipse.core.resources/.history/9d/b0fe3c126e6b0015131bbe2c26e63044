package ev3Navigation;
/* Lab 3 Navigation
 * Group 7
 * Sebastien Arrese & Arnold Kokoroko
 */
import lejos.hardware.sensor.*;
import lejos.hardware.ev3.LocalEV3;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.port.Port;
import lejos.robotics.SampleProvider;
import lejos.hardware.Button;

public class ObstacleAvoidanceNavigation extends Thread implements UltrasonicController {
	
	//private static final Port usPort = LocalEV3.get().getPort("S1");
	
	double currentX, currentY, targetX, targetY; // Current Position / Target Position
	double currentTheta;
	boolean obstaclePresent = false;
	private static final int rotationSpeed = 180; 
	private static final int fwdSpeed = 360; 
	private static final int turnSpeed = 240; 
	private static final int offCourseSpeed = 80;
	private static final int onCourseSpeed = 180;
	private int distance;

	double obstacleTheta; // theta when robot first sees obstacle
	Odometer odometer; 
	private static EV3LargeRegulatedMotor leftMotor, rightMotor;

	private static int countDistances; // the number of times sensor reads 255


	// Class constants
	private static final long navigationPeriod= 25;
	private static final double wheelRadius = 2.1; // right wheel radius (cm)
	private static final double wheelDistance = 15.5; // wheel track (cm)
	private static final double errorThreshold = 1; // degrees off heading
	private static final int objectLimit = 20;
	private static final int offCourseAngle = 15;
	private static final int onCourseAngle = 0;
	

	
	// Coordinates for Navigation
	Coordinate c0 = new Coordinate(0, 0); 
	Coordinate c1 = new Coordinate(0, 60);
	Coordinate c2 = new Coordinate(60,0); 
	
	public ObstacleAvoidanceNavigation(Odometer odometer,EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor){
		this.odometer = odometer;
		this.leftMotor = leftMotor;
		this.rightMotor = rightMotor;
	}
	
	public void processUSData(int distance) {
		this.distance = distance;
		odometer.setDistance(distance);
	}
	

	public void run() {
		
		long updateStart, updateEnd;
		while (true) {
				updateStart = System.currentTimeMillis();
				this.currentX = odometer.getX();
				this.currentY = odometer.getY();
				this.currentTheta = Math.toDegrees(odometer.getTheta()); //Converting Radians to Pi
				
				if (currentTheta > 180) {
					odometer.setTheta(currentTheta - 360);
				} else if (currentTheta < -180) {
					odometer.setTheta(currentTheta + 360);
				}
				
				
				if (c2.getIsVisited()) {
					leftMotor.stop();
					rightMotor.stop();
					break;
				} else if (c1.getIsVisited()) {
					setCoordinate(c2);
					c2.setIsVisited(currentX, currentY);
				} 
				else {
					setCoordinate(c1);
					c1.setIsVisited(currentX, currentY);
				} 
				
				//Normal Navigation when no Object
				if (obstaclePresent == false) {
					travelTo(targetX, targetY);
				} else {
				//Obstacle Avoidance
					avoidObstacle();
				}				
				updateEnd = System.currentTimeMillis();
				if (updateEnd - updateStart < navigationPeriod) {
					try {
						Thread.sleep(navigationPeriod - (updateEnd - updateStart));
					} catch (InterruptedException e) {
						// there is nothing to be done here because it is not
						// expected that the odometer will be interrupted by
						// another thread
					}
				}
					
		}
		
	}
	
	
	public void avoidObstacle(){
		if (this.distance< objectLimit ){
			rightMotor.setSpeed(20);		
		}
		
		else if (this.distance >= 255){
			leftMotor.setSpeed(fwdSpeed);
			rightMotor.setSpeed(fwdSpeed);
		}
		else{
			this.obstaclePresent = false;
		}
		
	}
	
	
	public void setCoordinate (Coordinate c){
		this.targetX = c.getX();
		this.targetY = c.getY();
	}
	
	// Travel to absolute field location
		public void travelTo(double x, double y) {

			// Coordinate difference
			double deltaX = x - this.currentX;
			double deltaY = y - this.currentY;
			double targetTheta = Math.toDegrees(Math.atan2(deltaX, deltaY));
			double deltaTheta = targetTheta - this.currentTheta; 
			
			// if the heading is off by more than acceptable error, we must correct
			if (Math.abs(deltaTheta) > errorThreshold) {
				turnTo(targetTheta);
			} else {
		
				leftMotor.setSpeed(fwdSpeed);
				rightMotor.setSpeed(fwdSpeed);
				leftMotor.forward();
				rightMotor.forward();
			}
			
			if( this.distance < objectLimit){
				this.obstaclePresent = true;
				this.obstacleTheta = odometer.getTheta();
				
			}
			
			

		}	

		public void turnTo(double theta) {
			double rotate = theta - this.currentTheta;	
			//Meaning Complete rotation
			if (c0.isAtPoint(currentX, currentY) || c1.isAtPoint(currentX, currentY) || c2.isAtPoint(currentX, currentY)){
				if (rotate> 180){
					rotate -= 360;
				} else if (rotate < -180){
					rotate += 360;
				}
				
				leftMotor.setSpeed(rotationSpeed);
				rightMotor.setSpeed(rotationSpeed);
				
				//Rotation starts
				leftMotor.rotate(convertAngle(wheelRadius, wheelDistance, rotate), true);
				rightMotor.rotate(-convertAngle(wheelRadius, wheelDistance, rotate), false);		
			}

			 else if (rotate > OFF_COURSE_ANGLE) {
					leftMotor.setSpeed(OFF_COURSE_SPEED); // turn left
					rightMotor.setSpeed(FORWARD_SPEED);
				} else if (rotate < -OFF_COURSE_ANGLE) {
					leftMotor.setSpeed(FORWARD_SPEED);
					rightMotor.setSpeed(OFF_COURSE_SPEED); // turn right
				} else if (rotate > ON_COURSE_ANGLE) {
					leftMotor.setSpeed(ON_COURSE_SPEED); // correct left
					rightMotor.setSpeed(FORWARD_SPEED);
				} else if (rotate < ON_COURSE_ANGLE) {
					leftMotor.setSpeed(FORWARD_SPEED);
					rightMotor.setSpeed(ON_COURSE_SPEED); // correct right
				}
				
		}
	
	
	private static int convertDistance(double radius, double distance) {
		return (int) ((180.0 * distance) / (Math.PI * radius));
	}

	private static int convertAngle(double radius, double width, double angle) {
		return convertDistance(radius, Math.PI * width * angle / 360.0);
	}

	public boolean isNavigating() {
		return false;
	}
	
	public int readUSDistance() {
		return this.distance;
	}


}
