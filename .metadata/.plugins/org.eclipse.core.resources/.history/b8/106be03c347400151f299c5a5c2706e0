package ev3ObjectRecognition;

import lejos.hardware.*;
import java.util.Arrays;
import lejos.hardware.ev3.LocalEV3;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.port.Port;
import lejos.hardware.sensor.*;
import lejos.robotics.SampleProvider;


public class BlockRecognition extends Thread {
	public final Object lock = new Object(); // for blocking method
	private static final int TIME_PERIOD = 20;
	private static final int FORWARD_SPEED = 150;
	private static final int STOP_DISTANCE = 7; // how far from block to stop
	private static final double RIGHT_RADIUS = 2.1;
	private static final double LEFT_RADIUS = 2.1;
	private static final double WIDTH = 15.6;
	private static final double CM_ERR = 1.5; // allowed error in position
	private Odometer odo;
	private boolean isStyro = false; // initialize to false
	private boolean isCinder = false;
	private boolean isFinished;
	private SampleProvider usSensor;
	private float[] usData;

	private int redValue, blueValue; // color readings

	private int distance, medianDistance;

	int[] distanceArray = new int[5];
	int[] sortedArray = new int[5];
	
	public BlockRecognition(Odometer odo, SampleProvider usSensor, float[] usData){
		this.odo = odo;
		this.usSensor = usSensor;
		this.usData = usData;
	}
	
	public void startRun(){
		
		long timeStart, timeEnd;

		double xInit = odo.getX(); // initial x position
		double yInit = odo.getY(); // initial y position
		
		while (true){
			timeStart = System.currentTimeMillis();



			// stop if close to a block
			if (getFilteredData() <= STOP_DISTANCE) {
				stop();
				setBlockType(); // determine block type

				if (isStyro) {
					grabBlock();
				} else {
					break;
				}

			} else {
				goForward();
				isCinder = false;
				isStyro = false;
			}

			timeEnd = System.currentTimeMillis();
			if (timeEnd - timeStart < TIME_PERIOD) {
				try {
					Thread.sleep(TIME_PERIOD - (timeEnd - timeStart));
				} catch (InterruptedException e) {
					// there is nothing to be done here because it is not
					// expected that the detector will be
					// interrupted by another thread
				}
			}
		}
		
		while (isNotThereYet(xInit, yInit)) {
			goBackward();
		}

		stop();
		isFinished = true;
		return;
		
		
	}
	
	private float getFilteredData() {
		usSensor.fetchSample(usData, 0);
		float distance = usData[0]*100;
				
		return distance;
	}

}
